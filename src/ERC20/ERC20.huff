/// @title ERC20 Huffswap V2
/// @notice SPDX-License-Identifier: MIT
/// @author 0x4non
/// @notice Modified from huffmate ERC20

#include "../SafeMath.huff"


// Interface
#define function allowance(address,address) view returns (uint256)
#define function balanceOf(address) view returns (uint256)
#define function totalSupply() view returns (uint256)

#define function approve(address,uint256) nonpayable returns ()
#define function transfer(address,uint256) nonpayable returns ()
#define function transferFrom(address,address,uint256) nonpayable returns ()

// erc 1363 partially implemented
#define function approveAndCall(address,uint256,bytes) nonpayable returns ()
#define function transferAndCall(address,uint256,bytes) nonpayable returns ()

// Events
#define event Approval(address indexed, address indexed, uint256)
#define event Transfer(address, address, uint256)

// Metadata
#define function decimals() nonpayable returns (uint256)
#define function name() nonpayable returns (string)
#define function symbol() nonpayable returns (string)

// ERC20 Storage
// #define constant TOTAL_SUPPLY_SLOT = not(0x00)
#define constant ADDRESS_MASK = 0xffffffffffffffffffffffffffffffffffffffff
// another alternative could be `0x60 shl 0x60 shr`, but this is more expensive in gas terms

#define macro NAME(z0) = takes(0) returns(0) {
  0x20 <z0> mstore
  // idea taken from Seaport
  // 0x0f "HuffSwap PairV2"
  0x0f487566665377617020506169725632 0x2f mstore
  0x60 <z0> return
}


#define macro SYMBOL(z0) = takes(0) returns(0) {
  0x20 <z0> mstore  
  // 0x0b "HUFFSWAP-V2"
  0x0b48554646535741502d5632 0x2b mstore
  0x60 <z0> return
}

#define macro DECIMALS(z0) = takes(0) returns(0) {
  // 18 = 0x12
  0x12 <z0> mstore
  0x20 <z0> return // return 18 decimals
}

#define macro BALANCE_OF(z0) = takes(0) returns (0) {
    0x04 calldataload   // [user]
    [ADDRESS_MASK] and
    sload               // [balance]

    <z0> mstore
    0x20 <z0> return
}


#define macro TOTAL_SUPPLY(z0) = takes(0) returns (0) {
    <z0> not
    sload               // [Total Supply]

    <z0> mstore
    0x20 <z0> return
}


#define macro GET_SLOT_FROM_KEYS(mem_ptr) = takes(2) returns(1) {
    // takes:                      [key2, key1]
    <mem_ptr> 0x20 add mstore   // [key2]
    <mem_ptr> mstore            // []
    0x40 <mem_ptr> sha3         // [hashed]
    // returns:                    [hashed]
}


#define macro ALLOWANCE(z0) = takes(0) returns(0) {
    0x24 calldataload           // [spender]
    [ADDRESS_MASK] and

    0x04 calldataload           // [spender, owner]
    [ADDRESS_MASK] and
        
    GET_SLOT_FROM_KEYS(<z0>)    // [slotAllowance]
    sload <z0> mstore
    0x20 <z0> return
}

#define macro APPROVE(z0) = takes(0) returns(0) {
    // takes:                      []
    0x04 calldataload [ADDRESS_MASK] and // [owner]
    caller                               // [owner, caller()]
    __EVENT_HASH(Approve)
    //                             [owner, caller(), _APPROVAL_EVENT_SIGNATURE]
    0x24 calldataload           // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, amount]
    dup1                        // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, amount, amount]
    dup5                        // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, amount, amount, owner]
    caller                      // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, amount, amount, owner, caller()]
    GET_SLOT_FROM_KEYS(<z0>)    // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, amount, amount, slot]
    sstore                      // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, amount]
    <z0> mstore                 // [owner, caller(), _APPROVAL_EVENT_SIGNATURE]
    0x20                        // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, 0x20]
    <z0>                        // [owner, caller(), _APPROVAL_EVENT_SIGNATURE, 0x20, z0]
    log3                        // []
    0x01 <z0> mstore
    0x20 <z0> return
}


#define macro USE_ALLOWANCE(z0) = takes(3) returns(0) {
    // takes:                      [amount, spender, from]
    GET_SLOT_FROM_KEYS(<z0>)    // [amount, slotAllowance]
    swap1                       // [slotAllowance, amount]
    dup2 sload                  // [slotAllowance, amount, allowance]
    dup1 <z0> not eq            // [slotAllowance, amount, allowance, allowance == type(uint256).max]
    
    skipDueInfiniteAllowance  jumpi
                                // [slotAllowance, amount, allowance]
    dup1 dup3 gt                // [slotAllowance, amount, allowance, allowance < amount]
    iszero
     allowanceNotOverflow jumpi
    
      // error InsufficientAllowance()
      __FUNC_SIG("InsufficientAllowance()") <z0> mstore
      0x04 0x1c revert

    allowanceNotOverflow:
                                // [slotAllowance, amount, allowance]
      sub                       // [slotAllowance, allowance - amount]
      swap1                     // [allowance - amount, slotAllowance]
      sstore
    endUseAllowance jump

    skipDueInfiniteAllowance:
    // [slotAllowance, amount, allowance]
    pop pop pop
    endUseAllowance:
    // []
    
}

#define macro TRANSFER(z0) = takes(0) returns(0) {
    // takes:                      []
    0x04 calldataload [ADDRESS_MASK] and // [receiver]
    <z0>                        // [receiver, z0]
    dup2                        // [receiver, z0, receiver]
    0x24 calldataload           // [receiver, z0, receiver, amount]
    dup1                        // [receiver, z0, receiver, amount, amount]
    
    dup2                        // [receiver, z0, receiver, amount, amount, amount]
    caller sload                // [receiver, z0, receiver, amount, amount, amount, balanceSender]
    // 0xf4d678b8 = 4bytes(InsufficientBalance.selector
    SAFE_SUB_ERR(<z0>, 0xf4d678b8)          // [receiver, z0, receiver, amount, amount, newSenderBalance]
    caller                      // [receiver, z0, receiver, amount, amount, amount, caller]
    sstore                      // [receiver, z0, receiver, amount, amount]
    dup3                        // [receiver, z0, receiver, amount, amount, receiver]
    sload                       // [receiver, z0, receiver, amount, amount, balanceReceiver]
    add                         // [receiver, z0, receiver, amount, newBalanceReceiver]
    swap3                       // [receiver, newBalanceReceiver, receiver, amount, z0]
    mstore                      // [receiver, newBalanceReceiver, receiver]
    sstore                      // [receiver]
    caller                      // [receiver, caller()]
    __EVENT_HASH(Transfer)
    //                             [receiver, caller(), _TRANSFER_EVENT_SIGNATURE]
    0x20                        // [receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20]
    <z0>                        // [receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20, z0]
    log3                        // []
    
    0x01 <z0> mstore                      // []
    0x20 <z0> return                      // []
    // returns:                    []
}

#define macro TRANSFER_FROM(z0) = takes(0) returns(0) {
        // takes:                      []
    0x24 calldataload [ADDRESS_MASK] and // [receiver]
    0x04 calldataload [ADDRESS_MASK] and // [receiver, from]
    0x44 calldataload           // [receiver, from, amount]
    
    dup1                        // [receiver, from, amount, amount]
    dup3                        // [receiver, from, amount, amount, from]
    sload                       // [receiver, from, amount, amount, balanceSender]
    dup3                        // [receiver, from, amount, amount, balanceSender, amount]
    caller                      // [receiver, from, amount, amount, balanceSender, amount, caller()]
    dup6                        // [receiver, from, amount, amount, balanceSender, amount, caller(), from]
    USE_ALLOWANCE(<z0>)         // [receiver, from, amount, amount, balanceSender]
    // 0xf4d678b8 = 4bytes(InsufficientBalance.selector
    SAFE_SUB_ERR(<z0>, 0xf4d678b8)              // [receiver, from, amount, newSenderBalance]
    dup2                        // [receiver, from, amount, newSenderBalance, amount]
    swap3                       // [receiver, amount, amount, newSenderBalance, from]
    sstore                      // [receiver, amount, amount]
    dup3                        // [receiver, amount, amount, receiver]
    sload                       // [receiver, amount, amount, balanceReceiver]
    add                         // [receiver, amount, newBalanceReceiver]
    dup3 sstore                  // [receiver, amount]
    <z0>                        // [receiver, amount, z0]
    mstore                      // [receiver]
    caller                      // [receiver, caller()]
    __EVENT_HASH(Transfer)
    //                             [receiver, caller(), _TRANSFER_EVENT_SIGNATURE]
    0x20                        // [receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20]
    <z0>                        // [receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20, z0]
    log3                        // []
    
    0x01 <z0> mstore                      // []
    0x20 <z0> return                      // []
    // returns:                    []
}

#define macro APPROVE_AND_CALL(z0, notEmptyCall) = takes(0) returns(0) {
    __FUNC_SIG("onApprovalReceived(address,uint256,bytes)") 0xe0 shl
    // takes:                      []
    <z0>                        // [0x0]
    0x20                        // [0x0, 0x20]
    <z0>                        // [0x0, 0x20, z0]
    calldatasize                // [0x0, 0x20, z0, calldatasize()]
    <z0>                        // [0x0, 0x20, z0, calldatasize(), z0]
    <z0>                        // [0x0, 0x20, z0, calldatasize(), z0, z0]
    0x04 calldataload [ADDRESS_MASK] and // [0x0, 0x20, z0, calldatasize(), z0, z0, spender]
    gas                         // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas()]
    0x04 calldatasize sub        // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4)]
    0x04                         // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4]
    0x04                         // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4]
    // onApprovalReceived(address,uint256,bytes)
    // 0x7b04a2d00000000...000000000
    dup12          // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes)]
    <z0>                        // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0]
    0x24 calldataload           // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount]
    dup8                        // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, spender]
    caller                      // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, spender, caller()]
    GET_SLOT_FROM_KEYS(<z0>)    // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, slot]
    dup2 <z0> mstore            // store amount for log
    
    dup9                        // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, slot, spender]
    caller                      // [..., 0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, slot, spender, caller()]
    __EVENT_HASH(Approve)
    //                             [..., 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, slot, spender, caller(), _APPROVAL_EVENT_SIGNATURE]
    0x20                        // [..., z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, slot, spender, caller(), _APPROVAL_EVENT_SIGNATURE, 0x20]
    <z0>                        // [..., calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, slot, spender, caller(), _APPROVAL_EVENT_SIGNATURE, 0x20, z0]
    log3                        // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0, amount, slot]
    sstore                      // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4, onApprovalReceived(address,uint256,bytes), z0]
    mstore                      // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas(), sub(calldatasize(), 0x4), 0x4, 0x4]
    calldatacopy                // [0x0, 0x20, z0, calldatasize(), z0, z0, spender, gas()]
    
    <notEmptyCall> isNotEmptyApproveCall jumpi
        0x60 0x44 mstore
        calldatasize 0x40 add swap5 pop
    isNotEmptyApproveCall:
    
    caller 0x04 mstore
    call                        // [0x1, 0x0, callOk]
    callIsOk jumpi
        __FUNC_SIG("Spender_onApprovalReceived_rejected()") <z0> mstore
        0x04 0x1c revert

    callIsOk:
    mload                       // [0x1, ret]
    eq onApprovalReceivedOk jumpi
        // error Spender_onApprovalReceived_rejected()
        0x81cbe4db <z0> mstore
        0x04 0x1c revert
    onApprovalReceivedOk:
    0x01 <z0> mstore                      // []
    0x20 <z0> return
    // returns:                    []
}

#define macro TRANSFER_AND_CALL(z0) = takes(0) returns(0) {
    __FUNC_SIG("onTransferReceived(address,address,uint256,bytes)") 0xe0 shl
    // takes:                      []
    0x04 calldataload [ADDRESS_MASK] and   // [funcSig, receiver]
    dup1                        // [funcSig, receiver, receiver]
    caller                      // [funcSig, receiver, receiver, caller()]
    0x24 calldataload           // [funcSig, receiver, receiver, caller(), amount]
    dup1                        // [funcSig, receiver, receiver, caller(), amount, amount]
    <z0>                        // [funcSig, receiver, receiver, caller(), amount, amount, z0]
    dup3                        // [funcSig, receiver, receiver, caller(), amount, amount, z0, amount]
    caller sload                // [funcSig, receiver, receiver, caller(), amount, amount, z0, amount, balanceSender]
    SAFE_SUB_ERR(<z0>, 0xf4d678b8)      // [funcSig, slot, amount, amount, newSenderBalance]
    caller                      // [funcSig, receiver, receiver, caller(), amount, amount, z0, newSenderBalance, caller()]
    sstore                      // [funcSig, receiver, receiver, caller(), amount, amount, z0]
    mstore                      // [funcSig, receiver, receiver, caller(), amount]
    dup3                        // [funcSig, receiver, receiver, caller(), amount, receiver]
    sload                       // [funcSig, receiver, receiver, caller(), amount, balanceReceiver]
    add                         // [funcSig, receiver, receiver, caller(), newBalanceReceiver]
    dup3                        // [funcSig, receiver, receiver, caller(), newBalanceReceiver, receiver]
    sstore                      // [funcSig, receiver, receiver, caller()]
    __EVENT_HASH(Transfer)
    //                             [funcSig, receiver, receiver, caller(), _TRANSFER_EVENT_SIGNATURE]
    0x20                        // [funcSig, receiver, receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20]
    <z0>                        // [funcSig, receiver, receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20, z0]
    log3                        // [funcSig, receiver]


    0x24 calldatasize sub       // [funcSig, receiver, callsize - 0x24]
    0x24                        // [funcSig, receiver, callsize - 0x24, 0x24]
    0x44                        // [funcSig, receiver, callsize - 0x24, 0x24, 0x44]
    calldatacopy                // [funcSig, receiver]
    
    
    dup2
    <z0> mstore
    caller 0x04 mstore
    caller 0x24 mstore
    0x80 0x64 mstore
    

        // takes:                      []
    <z0>                        // [funcSig, receiver, z0]
    calldatasize                // [funcSig, receiver, z0, calldatasize()]
    0x60                        // [funcSig, receiver, z0, calldatasize(), 0x60]
    add                         // [funcSig, receiver, z0, add(0x20, calldatasize())]
    <z0>                        // [funcSig, receiver, z0, add(0x20, calldatasize()), z0]
    <z0>                        // [funcSig, receiver, z0, add(0x20, calldatasize()), z0, z0]
    0x20 swap5                  // [funcSig, 0x20, z0, add(0x20, calldatasize()), z0, z0, receiver]
    gas                         // [funcSig, 0x20, z0, add(0x20, calldatasize()), z0, z0, receiver, gas()]
    call                        // [funcSig, callOk]
    callIsTransferOk jumpi
        // error Receiver_transferReceived_rejected()
        __FUNC_SIG("Receiver_transferReceived_rejected()") <z0> mstore
        0x04 0x1c revert

    callIsTransferOk:

    <z0> mload                       // [funcSig, ret]
    eq onTransferReceivedOk jumpi
        // error Receiver_transferReceived_rejected()
        0x85b16394 <z0> mstore
        0x04 0x1c revert
    onTransferReceivedOk:

    0x01 <z0> mstore                      // []
    0x20 <z0> return


    // returns:                    []
}

#define macro TRANSFER_FROM_AND_CALL(z0) = takes(0) returns(0) {
           // takes:                      []
    0x24 calldataload [ADDRESS_MASK] and // [receiver]
    0x04 calldataload [ADDRESS_MASK] and // [receiver, from]
    0x44 calldataload                    // [receiver, from, amount]
    dup1                        // [receiver, from, amount, amount]
    dup1                        // [receiver, from, amount, amount, amount]
    dup3 sload                  // [receiver, from, amount, amount, amount, sload(from) = balanceSender]
    dup2                        // [receiver, from, amount, amount, amount, balanceSender, amount]
    caller                      // [receiver, from, amount, amount, amount, balanceSender, amount, caller()]
    dup6                        // [receiver, from, amount, amount, amount, balanceSender, amount, caller(), from]
    USE_ALLOWANCE(<z0>)         // [receiver, from, amount, amount, amount, balanceSender]
    
    // 0xf4d678b8 = 4bytes(InsufficientBalance.selector
    SAFE_SUB_ERR(<z0>, 0xf4d678b8)              // [receiver, from, amount, amount, newSenderBalance = balanceSender - amount]
    dup3 sstore                                 // sstore()
    // [receiver, amount, amount]
    dup3                        // [receiver, amount, amount, receiver]
    sload                       // [receiver, amount, amount, balanceReceiver]
    add                         // [receiver, amount, newBalanceReceiver]
    dup3                        // [receiver, amount, newBalanceReceiver, receiver]
    sstore                      // [receiver, amount]
    <z0>                        // [receiver, amount, z0]
    mstore                      // [receiver]
    caller                      // [receiver, caller()]
    __EVENT_HASH(Transfer)
    //                             [receiver, caller(), _TRANSFER_EVENT_SIGNATURE]
    0x20                        // [receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20]
    <z0>                        // [receiver, caller(), _TRANSFER_EVENT_SIGNATURE, 0x20, z0]
    log3                        // []


    0x24 calldatasize sub       // [receiver, callsize - 0x24]
    0x24                        // [receiver, callsize - 0x24, 0x24]
    0x44                        // [receiver, callsize - 0x24, 0x24, 0x44]
    calldatacopy                // [receiver]
    
    
    __FUNC_SIG("onTransferReceived(address,address,uint256,bytes)") 0xe0 shl
    <z0> mstore
    caller 0x04 mstore
    0x04 calldataload 0x24 mstore
    0x80 0x64 mstore
    

        // takes:                      []
    <z0>                        // [receiver, z0]
    calldatasize                // [receiver, z0, calldatasize()]
    0x60                        // [receiver, z0, calldatasize(), 0x60]
    add                         // [receiver, z0, add(0x20, calldatasize())]
    <z0>                        // [receiver, z0, add(0x20, calldatasize()), z0]
    <z0>                        // [receiver, z0, add(0x20, calldatasize()), z0, z0]
    0x20 swap5                  // [0x20, z0, add(0x20, calldatasize()), z0, z0, receiver]
    gas                         // [0x20, z0, add(0x20, calldatasize()), z0, z0, receiver, gas()]
    call                        // [callOk]
    callIsTransferOk jumpi
        // error Receiver_transferReceived_rejected()
        __FUNC_SIG("Receiver_transferReceived_rejected()") <z0> mstore
        0x04 0x1c revert

    callIsTransferOk:

    <z0> mload                       // [ret]
    // bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))
    __FUNC_SIG("onTransferReceived(address,address,uint256,bytes)") 0xe0 shl
    eq onTransferReceivedOk jumpi
        // error Receiver_transferReceived_rejected()
        0x85b16394 <z0> mstore
        0x04 0x1c revert
    onTransferReceivedOk:

    0x01 <z0> mstore                      // []
    0x20 <z0> return


    // returns:                    []
}



#define macro _BURN(z0) = takes(2) returns(0) {
    // takes:                      [amount, to]
    <z0>                        // [amount, to, z0]
    swap2                       // [z0, to, amount]
    dup1                        // [z0, to, amount, amount]
    <z0>                        // [z0, to, amount, amount, z0]
    mstore                      // [z0, to, amount]
    dup2                        // [z0, to, amount, to]
    dup2                        // [z0, to, amount, to, amount]
    <z0> not                    // [z0, to, amount, to, amount, TOTAL_SUPPLY_SLOT]
    sload                       // [z0, to, amount, to, amount, totalBalance]
    SAFE_SUB(<z0>)              // [z0, to, amount, to, SAFE_SUB(totalBalance, amount)]
    <z0> not                    // [z0, to, amount, to, SAFE_SUB(totalBalance, amount), TOTAL_SUPPLY_SLOT]
    sstore                      // [z0, to, amount, to]
    sload                       // [z0, to, amount, _balance]
    SAFE_SUB(<z0>)                  // [z0, to, SAFE_SUB(_balance, amount)]
    dup2                        // [z0, to, SAFE_SUB(_balance, amount), to]
    sstore                      // [z0, to]
   __EVENT_HASH(Transfer)
    //                             [z0, to, _TRANSFER_EVENT_SIGNATURE]
    0x20                        // [z0, to, _TRANSFER_EVENT_SIGNATURE, 0x20]
    <z0>                        // [z0, to, _TRANSFER_EVENT_SIGNATURE, 0x20, z0]
    log3                        // []
    // returns:                    []
}

#define macro _MINT(z0) = takes(2) returns(0) {
    // takes:                      [amount, to]
    swap1                       // [to, amount]
    dup1                        // [to, amount, amount]
    <z0> not                    // [to, amount, amount, TOTAL_SUPPLY_SLOT]
    sload                       // [to, amount, amount, totalBalance]
    SAFE_ADD(<z0>)                  // [to, amount, SAFE_ADD(totalBalance, amount)]
    <z0> not                    // [to, amount, SAFE_ADD(totalBalance, amount), TOTAL_SUPPLY_SLOT]
    sstore                      // [to, amount]
    dup2                        // [to, amount, to]
    dup2                        // [to, amount, to, amount]
    <z0>                        // [to, amount, to, amount, z0]
    mstore                      // [to, amount, to]
    sload                       // [to, amount, _balance]
    SAFE_ADD(<z0>)                  // [to, SAFE_ADD(_balance, amount)]
    dup2                        // [to, SAFE_ADD(_balance, amount), to]
    sstore                      // [to]
    <z0>                        // [to, 0x0]
    __EVENT_HASH(Transfer)
    //                             [to, 0x0, _TRANSFER_EVENT_SIGNATURE]
    0x20                        // [to, 0x0, _TRANSFER_EVENT_SIGNATURE, 0x20]
    <z0>                        // [to, 0x0, _TRANSFER_EVENT_SIGNATURE, 0x20, z0]
    log3                        // []
    // returns:                    []
}
