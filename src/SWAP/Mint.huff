
// extern _MINT_FEE_IF_NOT() stack(3, 0)
#define macro _MINT_FEE_IF_NOT(z0) = takes(3) returns(0) {
    // takes:                           [reserve1, reserve0, klast, iszero(klast)]
    endMintFeeZeroCheck jumpi
    
    // takes:                      [reserve1, reserve0, klast]
    dup3                        // [reserve1, reserve0, klast, reserve1]
    dup3                        // [reserve1, reserve0, klast, reserve1, reserve0]

    // cant overflow (reserve are uint112); 0xffffffffffffffffffffffffffff * 0xffffffffffffffffffffffffffff = 0x00000000fffffffffffffffffffffffffffe0000000000000000000000000001
    mul                         // [reserve1, reserve0, klast, mul(reserve0, reserve1)]
    SQRT()                      // [reserve1, reserve0, klast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, klast]
    SQRT()                      // [reserve1, reserve0, klast, rootK, rootKLast]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK, rootKLast]
    lt                          // [reserve1, reserve0, klast, rootK, rootKLast, isGt]
    not skipMintFeeCalculation jumpi
    // stack here                  [reserve1, reserve0, klast, rootK, rootKLast]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK, rootKLast]
    _MINT_FEE_CALCULATE()       // [reserve1, reserve0, klast, rootK, rootKLast, liquidity]
    [FACTORY]                   // [reserve1, reserve0, klast, rootK, rootKLast, liquidity, FACTORY]
    _MINT(<z0>)                     // [reserve1, reserve0, klast, rootK, rootKLast]
    jump endMintFeeZeroCheck:
    // stack here                  [reserve1, reserve0, klast, rootK, rootKLast]
    pop                         // [reserve1, reserve0, klast, rootK]
    pop                         // [reserve1, reserve0, klast]
    // returns:                    [reserve1, reserve0, klast]

    endMintFeeZeroCheck:
    
    // expected stack:                           [reserve1, reserve0, klast]
    pop
    pop
    pop
}

// balls-insert-start
#define macro MINT(z0) = takes(0) returns(0) {
    // takes:                      []
    LOCK(<z0>)                  // []
    [PACKED_RESERVE_SLOT]       // [PACKED_RESERVE_SLOT]
    sload                       // [packedData]
    UNLOCK()                    // [packedData]
    dup1                        // [packedData, packedData]
    _GET_RESERVE1()             // [packedData, reserve1]
    swap1                       // [reserve1, packedData]
    _GET_RESERVE0()             // [reserve1, reserve0]
    dup2                        // [reserve1, reserve0, reserve1]
    dup2                        // [reserve1, reserve0, reserve1, reserve0]
    _MINT_CALCULATE(<z0>)       // [reserve1, reserve0, liquidityToMint]
    pop                         // [reserve1, reserve0]
    _MINT_FEE()                 // []
    0x4                         // [0x4]
    calldataload                // [to]
    pop                         // []
    // returns:                    []
}

#define macro _MINT_FEE() = takes(2) returns(0) {
    // takes:                      [reserve1, reserve0]
    [KLAST_SLOT]                // [reserve1, reserve0, KLAST_SLOT]
    sload                       // [reserve1, reserve0, klast]
    dup1                        // [reserve1, reserve0, klast, klast]
    iszero                      // [reserve1, reserve0, klast, iszero(klast)]
    _MINT_FEE_IF_NOT()          // []
    // returns:                    []
}

#define macro _MINT_FEE_CALCULATE() = takes(2) returns(1) {
    // takes:                      [rootK, rootKLast]
    dup2                        // [rootK, rootKLast, rootK]
    0x5                         // [rootK, rootKLast, rootK, 0x5]
    mul                         // [rootK, rootKLast, mul(0x5, rootK)]
    dup2                        // [rootK, rootKLast, mul(0x5, rootK), rootKLast]
    add                         // [rootK, rootKLast, add(rootKLast, mul(0x5, rootK))]
    swap2                       // [add(rootKLast, mul(0x5, rootK)), rootKLast, rootK]
    sub                         // [add(rootKLast, mul(0x5, rootK)), sub(rootK, rootKLast)]
    [TOTAL_SUPPLY_SLOT]         // [add(rootKLast, mul(0x5, rootK)), sub(rootK, rootKLast), TOTAL_SUPPLY_SLOT]
    sload                       // [add(rootKLast, mul(0x5, rootK)), sub(rootK, rootKLast), totalSupply]
    MUL_DIV()                   // [liquidity]
    // returns:                    [liquidity]
}

#define macro _auxTEMPLATE__MINT_FEE_IF_NOT() = takes(3) returns(3) {
    // takes:                      [reserve1, reserve0, klast]
    dup3                        // [reserve1, reserve0, klast, reserve1]
    dup3                        // [reserve1, reserve0, klast, reserve1, reserve0]
    mul                         // [reserve1, reserve0, klast, mul(reserve0, reserve1)]
    SQRT()                      // [reserve1, reserve0, klast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, klast]
    SQRT()                      // [reserve1, reserve0, klast, rootK, rootKLast]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK, rootKLast]
    lt                          // [reserve1, reserve0, klast, rootK, rootKLast, isGt]
    _REQUIRE(0x0, 0xff)         // [reserve1, reserve0, klast, rootK, rootKLast]
    _MINT_FEE_CALCULATE()       // [reserve1, reserve0, klast, liquidity]
    [FACTORY]                   // [reserve1, reserve0, klast, liquidity, FACTORY]
    _MINT()                     // [reserve1, reserve0, klast]
    // returns:                    [reserve1, reserve0, klast]
}
// balls-insert-end
