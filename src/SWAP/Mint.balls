/*
    // this low-level function should be called from a contract which performs important safety checks
    function mint(address to) external nonReentrant returns (uint256 liquidity) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        uint256 balance0 = token0.balanceOf(address(this));
        uint256 balance1 = token1.balanceOf(address(this));
        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;

        _mintFee(_reserve0, _reserve1);
        uint256 _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            liquidity = (amount0 * amount1).sqrt();
            if (liquidity <= MINIMUM_LIQUIDITY) revert ErrLatamswapInsufficientLiquidity();
            // Previous if checks the overflow
            unchecked {
                liquidity -= MINIMUM_LIQUIDITY;
            }
            // permanently lock the first MINIMUM_LIQUIDITY tokens
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            liquidity =
                FixedPointMathLib.min(amount0.mulDiv(_totalSupply, _reserve0), amount1.mulDiv(_totalSupply, _reserve1));
        }

        if (liquidity == 0) revert ErrLatamswapInsufficientLiquidity();

        _mint(to, liquidity);

        _update(balance0, balance1, _reserve0, _reserve1);
        // reserve0 and reserve1 are up-to-date
        kLast = uint256(reserve0) * uint256(reserve1);
        emit Mint(msg.sender, amount0, amount1);
    }
  */

extern _MINT_FEE_IF_NOT() stack(4, 0)
extern SQRT() stack(1, 1)
extern MUL_DIV() stack(3, 1) reads(CONTROL_FLOW)
extern _MINT() stack(2, 0) writes(STORAGE)
extern _GET_RESERVE0() stack(1, 1)
extern _GET_RESERVE1() stack(1, 1)
extern UNLOCK() stack(0, 0)
extern LOCK(z0) stack(0, 0)
extern _MINT_CALCULATE(z0) stack(2, 1)
extern _REQUIRE(z0, err) stack(1, 0) writes(CONTROL_FLOW)

const KLAST_SLOT
const TOTAL_SUPPLY_SLOT
const PACKED_RESERVE_SLOT
const FACTORY

fn MINT<z0>() -> () {
  LOCK<z0>()
  to = calldataload(0x04)
  packedData = sload(PACKED_RESERVE_SLOT)
  reserve0 = _GET_RESERVE0(packedData)
  reserve1 = _GET_RESERVE1(packedData)
  _MINT_FEE(reserve0, reserve1)
  liquidityToMint = _MINT_CALCULATE<z0>(reserve0, reserve1)
  UNLOCK()
}

fn _MINT_FEE(reserve0, reserve1) -> () {
  klast = sload(KLAST_SLOT)
  _MINT_FEE_IF_NOT(iszero(klast), klast, reserve0, reserve1)
}

// will use next function as template
fn _auxTEMPLATE__MINT_FEE_IF_NOT(klast, reserve0, reserve1) -> (klast, reserve0, reserve1) {
  rootK = SQRT(mul(reserve0, reserve1))
  rootKLast = SQRT(klast)
  isGt = gt(rootK, rootKLast)
  // replace this _REQUIRE with jumpi
  _REQUIRE<0x00, 0xff>(isGt)
  liquidity = _MINT_FEE_CALCULATE(rootKLast, rootK)
  _MINT(FACTORY, liquidity)
}


fn _MINT_FEE_CALCULATE(rootKLast, rootK) -> (liquidity) reads(CONTROL_FLOW) {
  totalSupply = sload(TOTAL_SUPPLY_SLOT)
  liquidity = MUL_DIV(totalSupply, sub(rootK, rootKLast), add(mul(rootK, 5), rootKLast))
}


