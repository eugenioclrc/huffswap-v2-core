/// @title HuffSwap Pair LP Token
/// @notice SPDX-License-Identifier: MIT
/// @author 0x4non
/// @notice Some ideas were taken from Solmate, Solady and Huffmate

// ERC1363, imports ERC20, SafeMath and Storage
#include "src/ERC165/main.huff"
#include "src/ERC1363/main.huff"
#include "src/libraries/ReentrancyGuard.huff"
#include "src/libraries/SafeERC20.huff"
#include "src/libraries/Immutables.huff"

#define event Sync(uint112 reserve0, uint112 reserve1)
#define event Swap(address indexed sender,uint256 amount0In,uint256 amount1In,uint256 amount0Out,uint256 amount1Out,address indexed to)
#define event Mint(address indexed sender, uint amount0, uint amount1)

#define macro FACTORY(z0) = takes(0) returns(1) {
    _GET_IMMUTABLE(0x60, 0x00) // [token0]
}

#define macro TOKEN0(z0) = takes(0) returns(1) {
    _GET_IMMUTABLE(0x40, 0x00) // [token0]
} 

#define macro TOKEN1(z0) = takes(0) returns(1) {
    _GET_IMMUTABLE(0x20, 0x00) // [token0]
} 


// balls-insert-start
#define macro GET_RESERVES(z0) = takes(0) returns(3) {
    // takes:                      []
    [PACKED_RESERVE_SLOT]       // [PACKED_RESERVE_SLOT]
    sload                       // [packedReserveSlot]
    dup1                        // [packedReserveSlot, packedReserveSlot]
    _GET_RESERVE1()             // [packedReserveSlot, reserve1]
    dup2                        // [packedReserveSlot, reserve1, packedReserveSlot]
    _GET_BLOCK_TIMESTAMP_LAST()
    //                             [packedReserveSlot, reserve1, blockTimestampLast]
    swap2                       // [blockTimestampLast, reserve1, packedReserveSlot]
    _GET_RESERVE0()             // [blockTimestampLast, reserve1, reserve0]
    0x60                        // [blockTimestampLast, reserve1, reserve0, 0x60]
    dup4                        // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast]
    dup3                        // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast, reserve0]
    <z0>                        // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast, reserve0, z0]
    mstore                      // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast]
    dup4                        // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast, reserve1]
    0x20                        // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast, reserve1, 0x20]
    mstore                      // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast]
    0x40                        // [blockTimestampLast, reserve1, reserve0, 0x60, blockTimestampLast, 0x40]
    mstore                      // [blockTimestampLast, reserve1, reserve0, 0x60]
    <z0>                        // [blockTimestampLast, reserve1, reserve0, 0x60, z0]
    return                      // [blockTimestampLast, reserve1, reserve0]
    // returns:                    [blockTimestampLast, reserve1, reserve0]
}

#define macro K_LAST(z0) = takes(0) returns(0) {
    // takes:                      []
    0x20                        // [0x20]
    [KLAST_SLOT]                // [0x20, KLAST_SLOT]
    sload                       // [0x20, kLast]
    <z0>                        // [0x20, kLast, z0]
    mstore                      // [0x20]
    <z0>                        // [0x20, z0]
    return                      // []
    // returns:                    []
}

#define macro PRICE0_CUMULATIVE_LAST(z0) = takes(0) returns(0) {
    // takes:                      []
    0x20                        // [0x20]
    [P0CUMULATIVE_SLOT]         // [0x20, P0CUMULATIVE_SLOT]
    sload                       // [0x20, price0CumulativeLast]
    <z0>                        // [0x20, price0CumulativeLast, z0]
    mstore                      // [0x20]
    <z0>                        // [0x20, z0]
    return                      // []
    // returns:                    []
}

#define macro PRICE1_CUMULATIVE_LAST(z0) = takes(0) returns(0) {
    // takes:                      []
    0x20                        // [0x20]
    [P1CUMULATIVE_SLOT]         // [0x20, P1CUMULATIVE_SLOT]
    sload                       // [0x20, price1CumulativeLast]
    <z0>                        // [0x20, price1CumulativeLast, z0]
    mstore                      // [0x20]
    <z0>                        // [0x20, z0]
    return                      // []
    // returns:                    []
}

#define macro _GET_BLOCK_TIMESTAMP_LAST() = takes(1) returns(1) {
    // takes:                      [packedReserveSlot]
    [BLOCK_TIMESTAMP_LAST_OFFSET]
    //                             [packedReserveSlot, BLOCK_TIMESTAMP_LAST_OFFSET]
    shr                         // [blockTimestampLast]
    // returns:                    [blockTimestampLast]
}

#define macro _GET_RESERVE0() = takes(1) returns(1) {
    // takes:                      [packedReserveSlot]
    0xffffffffffffffffffffffffffff
    //                             [packedReserveSlot, 0xffffffffffffffffffffffffffff]
    and                         // [reserve0]
    // returns:                    [reserve0]
}

#define macro _GET_RESERVE1() = takes(1) returns(1) {
    // takes:                      [packedReserveSlot]
    [RESERVE1_OFFSET]           // [packedReserveSlot, RESERVE1_OFFSET]
    shr                         // [shr(RESERVE1_OFFSET, packedReserveSlot)]
    0xffffffffffffffffffffffffffff
    //                             [shr(RESERVE1_OFFSET, packedReserveSlot), 0xffffffffffffffffffffffffffff]
    and                         // [reserve1]
    // returns:                    [reserve1]
}
// balls-insert-end


// extern (z0) stack(3, 0) reads(CONTROL_FLOW)
#define macro _UPDATE_CUMULATIVE_IFNEED(z0) = takes(3) returns(0) {
    // takes:                      [reserve1, reserve0, timeElapsed]
    dup3                    // [reserve1, reserve0, timeElapsed, reserve1]  
    dup3                    // [reserve1, reserve0, timeElapsed, reserve1, reserve0]
    dup3                    // [reserve1, reserve0, timeElapsed, reserve1, reserve0, timeElapsed]
    or                      // [reserve1, reserve0, timeElapsed, reserve1, reserve0 | timeElapsed]
    or                      // [reserve1, reserve0, timeElapsed, reserve1 | reserve0 | timeElapsed]
    iszero                  // [reserve1, reserve0, timeElapsed, (reserve1 | reserve0 | timeElapsed) == 0]
    skipCumulativeUpdate jumpi
    // takes:                      [reserve1, reserve0, timeElapsed]
    _UPDATE_CUMULATIVE(<z0>)
    // returns:                    [amount, allowanceAmount, allowanceSlot]
    skipCumulativeUpdate:
    pop pop pop
    // returns:                    []    
}


// balls-insert-start
#define macro ENCODE_UQ112() = takes(1) returns(1) {
    // takes:                      [r]
    0x10000000000000000000000000000
    //                             [r, 0x10000000000000000000000000000]
    mul                         // [mul(0x10000000000000000000000000000, r)]
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    //                             [mul(0x10000000000000000000000000000, r), maskUint224]
    and                         // [encoded]
    // returns:                    [encoded]
}

#define macro UQ_DIV() = takes(2) returns(1) {
    // takes:                      [y, x]
    div                         // [div(x, y)]
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    //                             [div(x, y), maskUint224]
    and                         // [z]
    // returns:                    [z]
}

#define macro _EMIT_SYNC(z0) = takes(2) returns(0) {
    // takes:                      [balance1, balance0]
    <z0>                        // [balance1, balance0, z0]
    mstore                      // [balance1]
    0x20                        // [balance1, 0x20]
    mstore                      // []
    __EVENT_HASH(Sync)     // __EVENT_HASH(Sync)
    0x40                        // [_SYNC_EVENT_SIGNATURE, 0x40]
    <z0>                        // [_SYNC_EVENT_SIGNATURE, 0x40, z0]
    log1                        // []
    // returns:                    []
}

#define macro _UPDATE(z0) = takes(5) returns(0) {
    // takes:                      [blockTimestampLast, reserve1, reserve0, balance1, balance0]
    swap3                       // [blockTimestampLast, balance0, reserve0, balance1, reserve1]
    swap2                       // [blockTimestampLast, balance0, reserve1, balance1, reserve0]
    swap1                       // [blockTimestampLast, balance0, reserve1, reserve0, balance1]
    swap4                       // [balance1, balance0, reserve1, reserve0, blockTimestampLast]
    0xffffffffffffffffffffffffffff
    //                             [balance1, balance0, reserve1, reserve0, blockTimestampLast, 0xffffffffffffffffffffffffffff]
    dup6                        // [balance1, balance0, reserve1, reserve0, blockTimestampLast, 0xffffffffffffffffffffffffffff, balance1]
    gt                          // [balance1, balance0, reserve1, reserve0, blockTimestampLast, gt(balance1, 0xffffffffffffffffffffffffffff)]
    0xffffffffffffffffffffffffffff
    //                             [balance1, balance0, reserve1, reserve0, blockTimestampLast, gt(balance1, 0xffffffffffffffffffffffffffff), 0xffffffffffffffffffffffffffff]
    dup6                        // [balance1, balance0, reserve1, reserve0, blockTimestampLast, gt(balance1, 0xffffffffffffffffffffffffffff), 0xffffffffffffffffffffffffffff, balance0]
    gt                          // [balance1, balance0, reserve1, reserve0, blockTimestampLast, gt(balance1, 0xffffffffffffffffffffffffffff), gt(balance0, 0xffffffffffffffffffffffffffff)]
    iszero                      // [balance1, balance0, reserve1, reserve0, blockTimestampLast, gt(balance1, 0xffffffffffffffffffffffffffff), notOverflowBalance0]
    REQUIRE(<z0>, 0x35278d12)   // [balance1, balance0, reserve1, reserve0, blockTimestampLast, gt(balance1, 0xffffffffffffffffffffffffffff)]
    iszero                      // [balance1, balance0, reserve1, reserve0, blockTimestampLast, notOverflowBalance1]
    REQUIRE(<z0>, 0x35278d12)   // [balance1, balance0, reserve1, reserve0, blockTimestampLast]
    timestamp                   // [balance1, balance0, reserve1, reserve0, blockTimestampLast, timestamp()]
    sub                         // [balance1, balance0, reserve1, reserve0, sub(timestamp(), blockTimestampLast)]
    0xffffffff                  // [balance1, balance0, reserve1, reserve0, sub(timestamp(), blockTimestampLast), 0xffffffff]
    and                         // [balance1, balance0, reserve1, reserve0, timeElapsed]
    _UPDATE_CUMULATIVE_IFNEED(<z0>)
    //                             [balance1, balance0]
    dup2                        // [balance1, balance0, balance1]
    dup2                        // [balance1, balance0, balance1, balance0]
    _UPDATE_PACKED_RESERVE(<z0>)
    //                             [balance1, balance0]
    _EMIT_SYNC(<z0>)            // []
    // returns:                    []
}

#define macro _UPDATE_CUMULATIVE(z0) = takes(3) returns(3) {
    // takes:                      [reserve1, reserve0, timeElapsed]
    [P1CUMULATIVE_SLOT]         // [reserve1, reserve0, timeElapsed, P1CUMULATIVE_SLOT]
    sload                       // [reserve1, reserve0, timeElapsed, p1cumulative]
    dup2                        // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed]
    dup3                        // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, timeElapsed]
    dup5                        // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, timeElapsed, reserve0]
    dup7                        // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, timeElapsed, reserve0, reserve1]
    ENCODE_UQ112()              // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, timeElapsed, reserve0, ENCODE_UQ112<>(reserve1)]
    UQ_DIV()                    // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, timeElapsed, UQ_DIV<>(ENCODE_UQ112<>(reserve1), reserve0)]
    mul                         // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, p0]
    [P0CUMULATIVE_SLOT]         // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, p0, P0CUMULATIVE_SLOT]
    sload                       // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, p0, p0cumulative]
    add                         // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, add(p0cumulative, p0)]
    [P0CUMULATIVE_SLOT]         // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, add(p0cumulative, p0), P0CUMULATIVE_SLOT]
    sstore                      // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed]
    dup5                        // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, reserve1]
    dup5                        // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, reserve1, reserve0]
    ENCODE_UQ112()              // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, reserve1, ENCODE_UQ112<>(reserve0)]
    UQ_DIV()                    // [reserve1, reserve0, timeElapsed, p1cumulative, timeElapsed, UQ_DIV<>(ENCODE_UQ112<>(reserve0), reserve1)]
    mul                         // [reserve1, reserve0, timeElapsed, p1cumulative, p1]
    add                         // [reserve1, reserve0, timeElapsed, add(p1, p1cumulative)]
    [P1CUMULATIVE_SLOT]         // [reserve1, reserve0, timeElapsed, add(p1, p1cumulative), P1CUMULATIVE_SLOT]
    sstore                      // [reserve1, reserve0, timeElapsed]
    // returns:                    [reserve1, reserve0, timeElapsed]
}

#define macro _UPDATE_PACKED_RESERVE(z0) = takes(2) returns(0) {
    // takes:                      [balance1, balance0]
    swap1                       // [balance0, balance1]
    [RESERVE1_OFFSET]           // [balance0, balance1, RESERVE1_OFFSET]
    shl                         // [balance0, shl(RESERVE1_OFFSET, balance1)]
    timestamp                   // [balance0, shl(RESERVE1_OFFSET, balance1), timestamp()]
    [BLOCK_TIMESTAMP_LAST_OFFSET]
    //                             [balance0, shl(RESERVE1_OFFSET, balance1), timestamp(), BLOCK_TIMESTAMP_LAST_OFFSET]
    shl                         // [balance0, shl(RESERVE1_OFFSET, balance1), shl(BLOCK_TIMESTAMP_LAST_OFFSET, timestamp())]
    or                          // [balance0, or(shl(BLOCK_TIMESTAMP_LAST_OFFSET, timestamp()), shl(RESERVE1_OFFSET, balance1))]
    or                          // [packedData]
    [PACKED_RESERVE_SLOT]       // [packedData, PACKED_RESERVE_SLOT]
    sstore                      // []
    // returns:                    []
}
// balls-insert-end



// extern _MINT_FEE_IF_NOT() stack(4, 0)
#define macro _MINT_FEE_IF_NOT(z0) = takes(4) returns(0) {
    // takes:                           [reserve1, reserve0, klast, iszero(klast)]
    endMintFeeZeroCheck jumpi
    
    // takes:                      [reserve1, reserve0, klast]
    dup3                        // [reserve1, reserve0, klast, reserve1]
    dup3                        // [reserve1, reserve0, klast, reserve1, reserve0]

    // cant overflow (reserve are uint112); 0xffffffffffffffffffffffffffff * 0xffffffffffffffffffffffffffff = 0x00000000fffffffffffffffffffffffffffe0000000000000000000000000001
    mul                         // [reserve1, reserve0, klast, mul(reserve0, reserve1)]
    SQRT()                      // [reserve1, reserve0, klast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, klast]
    SQRT()                      // [reserve1, reserve0, klast, rootK, rootKLast]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK, rootKLast]
    lt                          // [reserve1, reserve0, klast, rootK, rootKLast, isGt]
    iszero
    skipMintFeeCalculation jumpi
    // stack here                  [reserve1, reserve0, klast, rootK, rootKLast]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK]
    dup2                        // [reserve1, reserve0, klast, rootK, rootKLast, rootK, rootKLast]
    _MINT_FEE_CALCULATE(<z0>)   // [reserve1, reserve0, klast, rootK, rootKLast, liquidity]
    FACTORY(<z0>)               // [reserve1, reserve0, klast, rootK, rootKLast, liquidity, FACTORY]
    _MINT(<z0>)                 // [reserve1, reserve0, klast, rootK, rootKLast]
    skipMintFeeCalculation:
    // stack here                  [reserve1, reserve0, klast, rootK, rootKLast]
    pop                         // [reserve1, reserve0, klast, rootK]
    pop                         // [reserve1, reserve0, klast]
    // returns:                    [reserve1, reserve0, klast]

    endMintFeeZeroCheck:
    
    // expected stack:                           [reserve1, reserve0, klast]
    pop
    pop
    pop
}

#define macro _MINT_CALCULATE(z0) = takes(4) returns(2) {
    // takes:                      [reserve1, reserve0, amount1, amount0]
    [TOTAL_SUPPLY_SLOT]         // [reserve1, reserve0, amount1, amount0, TOTAL_SUPPLY_SLOT]
    sload                       // [reserve1, reserve0, amount1, amount0, totalSupply]

    dup1 notFirstDepositJump jumpi
    
    // stack:                      [reserve1, reserve0, amount1, amount0, totalSupply]
    _CALC_LIQUIDITY_FIRST_DEPOSIT(<z0>)
    // stack: [liquidityToMint]
    endCalcLiquidity jump

    notFirstDepositJump:
    // calculate liquidity for mint knowing that totalSupply > 0
    // stack:                      [reserve1, reserve0, amount1, amount0, totalSupply]
    _CALC_LIQUIDITY_HAS_SUPPLY(<z0>)
    // stack: [liquidityToMint]
    
    endCalcLiquidity:
    // returns:                    [liquidityToMint]
}

// balls-insert-start
#define macro MINT(z0) = takes(0) returns(0) {
    // takes:                      []
    LOCK(<z0>)                  // []
    [PACKED_RESERVE_SLOT]       // [PACKED_RESERVE_SLOT]
    sload                       // [packedReserveSlot]
    dup1                        // [packedReserveSlot, packedReserveSlot]
    _GET_BLOCK_TIMESTAMP_LAST()
    //                             [packedReserveSlot, blockTimestampLast]
    SELF_BALANCE_TOKEN0(<z0>)   // [packedReserveSlot, blockTimestampLast, balance0]
    SELF_BALANCE_TOKEN1(<z0>)   // [packedReserveSlot, blockTimestampLast, balance0, balance1]
    dup1                        // [packedReserveSlot, blockTimestampLast, balance0, balance1, balance1]
    dup5                        // [packedReserveSlot, blockTimestampLast, balance0, balance1, balance1, packedReserveSlot]
    _GET_RESERVE1()             // [packedReserveSlot, blockTimestampLast, balance0, balance1, balance1, reserve1]
    swap5                       // [reserve1, blockTimestampLast, balance0, balance1, balance1, packedReserveSlot]
    _GET_RESERVE0()             // [reserve1, blockTimestampLast, balance0, balance1, balance1, reserve0]
    swap4                       // [reserve1, reserve0, balance0, balance1, balance1, blockTimestampLast]
    dup6                        // [reserve1, reserve0, balance0, balance1, balance1, blockTimestampLast, reserve1]
    dup6                        // [reserve1, reserve0, balance0, balance1, balance1, blockTimestampLast, reserve1, reserve0]
    dup5                        // [reserve1, reserve0, balance0, balance1, balance1, blockTimestampLast, reserve1, reserve0, balance1]
    dup7                        // [reserve1, reserve0, balance0, balance1, balance1, blockTimestampLast, reserve1, reserve0, balance1, balance0]
    _UPDATE(<z0>)               // [reserve1, reserve0, balance0, balance1, balance1]
    dup5                        // [reserve1, reserve0, balance0, balance1, balance1, reserve1]
    dup5                        // [reserve1, reserve0, balance0, balance1, balance1, reserve1, reserve0]
    dup5                        // [reserve1, reserve0, balance0, balance1, balance1, reserve1, reserve0, balance0]
    SAFE_SUB_ERR(<z0>, 0x2a2ab278)
    //                             [reserve1, reserve0, balance0, balance1, balance1, reserve1, amount0]
    swap3                       // [reserve1, reserve0, balance0, amount0, balance1, reserve1, balance1]
    SAFE_SUB_ERR(<z0>, 0x2a2ab278)
    //                             [reserve1, reserve0, balance0, amount0, balance1, amount1]
    swap3                       // [reserve1, reserve0, amount1, amount0, balance1, balance0]
    dup6                        // [reserve1, reserve0, amount1, amount0, balance1, balance0, reserve1]
    dup6                        // [reserve1, reserve0, amount1, amount0, balance1, balance0, reserve1, reserve0]
    _MINT_FEE(<z0>)             // [reserve1, reserve0, amount1, amount0, balance1, balance0]
    SAFE_MUL(<z0>)              // [reserve1, reserve0, amount1, amount0, SAFE_MUL<z0>(balance0, balance1)]
    [KLAST_SLOT]                // [reserve1, reserve0, amount1, amount0, SAFE_MUL<z0>(balance0, balance1), KLAST_SLOT]
    dup4                        // [reserve1, reserve0, amount1, amount0, SAFE_MUL<z0>(balance0, balance1), KLAST_SLOT, amount1]
    dup4                        // [reserve1, reserve0, amount1, amount0, SAFE_MUL<z0>(balance0, balance1), KLAST_SLOT, amount1, amount0]
    _EMIT_MINT(<z0>)            // [reserve1, reserve0, amount1, amount0, SAFE_MUL<z0>(balance0, balance1), KLAST_SLOT]
    sstore                      // [reserve1, reserve0, amount1, amount0]
    _MINT_CALCULATE(<z0>)       // [liquidityToMint]
    dup1                        // [liquidityToMint, liquidityToMint]
    <z0>                        // [liquidityToMint, liquidityToMint, z0]
    mstore                      // [liquidityToMint]
    0x4                         // [liquidityToMint, 0x4]
    calldataload                // [liquidityToMint, to]
    _MINT(<z0>)                 // []
    UNLOCK()                    // []
    0x20                        // [0x20]
    <z0>                        // [0x20, z0]
    return                      // []
    // returns:                    []
}

#define macro _CALC_LIQUIDITY_FIRST_DEPOSIT(z0) = takes(5) returns(1) {
    // takes:                      [reserve0, reserve1, amount0, amount1, totalSupply]
    swap2                       // [reserve0, reserve1, totalSupply, amount1, amount0]
    SAFE_MUL(<z0>)              // [reserve0, reserve1, totalSupply, SAFE_MUL<z0>(amount0, amount1)]
    SQRT()                      // [reserve0, reserve1, totalSupply, liquidityToMint]
    [MINIMUM_LIQUIDITY]         // [reserve0, reserve1, totalSupply, liquidityToMint, MINIMUM_LIQUIDITY]
    dup2                        // [reserve0, reserve1, totalSupply, liquidityToMint, MINIMUM_LIQUIDITY, liquidityToMint]
    sub                         // [reserve0, reserve1, totalSupply, liquidityToMint, liquidityToMint]
    swap4                       // [liquidityToMint, reserve1, totalSupply, liquidityToMint, reserve0]
    pop                         // [liquidityToMint, reserve1, totalSupply, liquidityToMint]
    [MINIMUM_LIQUIDITY]         // [liquidityToMint, reserve1, totalSupply, liquidityToMint, MINIMUM_LIQUIDITY]
    <z0>                        // [liquidityToMint, reserve1, totalSupply, liquidityToMint, MINIMUM_LIQUIDITY, z0]
    _MINT(<z0>)                 // [liquidityToMint, reserve1, totalSupply, liquidityToMint]
    [MINIMUM_LIQUIDITY]         // [liquidityToMint, reserve1, totalSupply, liquidityToMint, MINIMUM_LIQUIDITY]
    lt                          // [liquidityToMint, reserve1, totalSupply, lt(MINIMUM_LIQUIDITY, liquidityToMint)]
    REQUIRE(<z0>, 0xbb55fd27)   // [liquidityToMint, reserve1, totalSupply]
    pop                         // [liquidityToMint, reserve1]
    pop                         // [liquidityToMint]
    // returns:                    [liquidityToMint]
}

#define macro _CALC_LIQUIDITY_HAS_SUPPLY(z0) = takes(5) returns(1) {
    // takes:                      [reserve0, reserve1, amount0, amount1, totalSupply]
    swap2                       // [reserve0, reserve1, totalSupply, amount1, amount0]
    swap4                       // [amount0, reserve1, totalSupply, amount1, reserve0]
    swap3                       // [amount0, reserve0, totalSupply, amount1, reserve1]
    swap1                       // [amount0, reserve0, totalSupply, reserve1, amount1]
    dup3                        // [amount0, reserve0, totalSupply, reserve1, amount1, totalSupply]
    swap1                       // [amount0, reserve0, totalSupply, reserve1, totalSupply, amount1]
    MUL_DIV(<z0>)               // [amount0, reserve0, totalSupply, MUL_DIV<z0>(amount1, totalSupply, reserve1)]
    swap3                       // [MUL_DIV<z0>(amount1, totalSupply, reserve1), reserve0, totalSupply, amount0]
    MUL_DIV(<z0>)               // [MUL_DIV<z0>(amount1, totalSupply, reserve1), MUL_DIV<z0>(amount0, totalSupply, reserve0)]
    MIN()                       // [liquidityToMint]
    dup1                        // [liquidityToMint, liquidityToMint]
    REQUIRE(<z0>, 0xbb55fd27)   // [liquidityToMint]
    // returns:                    [liquidityToMint]
}

#define macro _EMIT_MINT(z0) = takes(2) returns(0) {
    // takes:                      [amount1, amount0]
    <z0>                        // [amount1, amount0, z0]
    mstore                      // [amount1]
    0x20                        // [amount1, 0x20]
    mstore                      // []
    caller                      // [caller()]
    __EVENT_HASH(Mint)     // [caller(), _MINT_EVENT_SIGNATURE]
    0x40                        // [caller(), _MINT_EVENT_SIGNATURE, 0x40]
    <z0>                        // [caller(), _MINT_EVENT_SIGNATURE, 0x40, z0]
    log2                        // []
    // returns:                    []
}

#define macro _MINT_FEE(z0) = takes(2) returns(0) {
    // takes:                      [reserve1, reserve0]
    [KLAST_SLOT]                // [reserve1, reserve0, KLAST_SLOT]
    sload                       // [reserve1, reserve0, klast]
    dup1                        // [reserve1, reserve0, klast, klast]
    iszero                      // [reserve1, reserve0, klast, iszero(klast)]
    _MINT_FEE_IF_NOT(<z0>)      // []
    // returns:                    []
}

#define macro _MINT_FEE_CALCULATE(z0) = takes(2) returns(1) {
    // takes:                      [rootK, rootKLast]
    dup2                        // [rootK, rootKLast, rootK]
    0x5                         // [rootK, rootKLast, rootK, 0x5]
    mul                         // [rootK, rootKLast, mul(0x5, rootK)]
    dup2                        // [rootK, rootKLast, mul(0x5, rootK), rootKLast]
    add                         // [rootK, rootKLast, add(rootKLast, mul(0x5, rootK))]
    swap2                       // [add(rootKLast, mul(0x5, rootK)), rootKLast, rootK]
    sub                         // [add(rootKLast, mul(0x5, rootK)), sub(rootK, rootKLast)]
    [TOTAL_SUPPLY_SLOT]         // [add(rootKLast, mul(0x5, rootK)), sub(rootK, rootKLast), TOTAL_SUPPLY_SLOT]
    sload                       // [add(rootKLast, mul(0x5, rootK)), sub(rootK, rootKLast), totalSupply]
    MUL_DIV(<z0>)               // [liquidity]
    // returns:                    [liquidity]
}
// balls-insert-end


// balls-insert-start
#define macro BURN(z0) = takes(0) returns(0) {
    // takes:                      []
    [PACKED_RESERVE_SLOT]       // [PACKED_RESERVE_SLOT]
    LOCK(<z0>)                  // [PACKED_RESERVE_SLOT]
    sload                       // [packedReserveSlot]
    _BURN_AMOUNT()              // [packedReserveSlot, burnAmount]
    SELF_BALANCE_TOKEN0(<z0>)   // [packedReserveSlot, burnAmount, balance0]
    swap1                       // [packedReserveSlot, balance0, burnAmount]
    SELF_BALANCE_TOKEN1(<z0>)   // [packedReserveSlot, balance0, burnAmount, balance1]
    dup4                        // [packedReserveSlot, balance0, burnAmount, balance1, packedReserveSlot]
    _GET_RESERVE1()             // [packedReserveSlot, balance0, burnAmount, balance1, reserve1]
    dup5                        // [packedReserveSlot, balance0, burnAmount, balance1, reserve1, packedReserveSlot]
    _GET_RESERVE0()             // [packedReserveSlot, balance0, burnAmount, balance1, reserve1, reserve0]
    0x4                         // [packedReserveSlot, balance0, burnAmount, balance1, reserve1, reserve0, 0x4]
    calldataload                // [packedReserveSlot, balance0, burnAmount, balance1, reserve1, reserve0, to]
    swap6                       // [to, balance0, burnAmount, balance1, reserve1, reserve0, packedReserveSlot]
    _GET_BLOCK_TIMESTAMP_LAST()
    //                             [to, balance0, burnAmount, balance1, reserve1, reserve0, blockTimestampLast]
    swap3                       // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, balance1]
    dup3                        // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, balance1, reserve1]
    dup3                        // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, balance1, reserve1, reserve0]
    _MINT_FEE(<z0>)             // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, balance1]
    _TOTAL_SUPPLY()             // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, balance1, totalSupply]
    dup1                        // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, balance1, totalSupply, totalSupply]
    swap2                       // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, totalSupply, totalSupply, balance1]
    dup7                        // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, totalSupply, totalSupply, balance1, burnAmount]
    MUL_DIV(<z0>)               // [to, balance0, burnAmount, blockTimestampLast, reserve1, reserve0, totalSupply, amount1]
    swap6                       // [to, amount1, burnAmount, blockTimestampLast, reserve1, reserve0, totalSupply, balance0]
    dup6                        // [to, amount1, burnAmount, blockTimestampLast, reserve1, reserve0, totalSupply, balance0, burnAmount]
    MUL_DIV(<z0>)               // [to, amount1, burnAmount, blockTimestampLast, reserve1, reserve0, amount0]
    swap4                       // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, burnAmount]
    dup6                        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, burnAmount, amount1]
    dup6                        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, burnAmount, amount1, amount0]
    or                          // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, burnAmount, or(amount0, amount1)]
    REQUIRE(<z0>, 0x749383ad)   // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, burnAmount]
    address                     // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, burnAmount, address()]
    _BURN(<z0>)                 // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0]
    dup5                        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, amount1]
    dup7                        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, amount1, to]
    dup6                        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, amount1, to, amount0]
    dup9                        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, amount1, to, amount0, to]
    TOKEN0(<z0>)                // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, amount1, to, amount0, to, TOKEN0<z0>()]
    ERC20_TRANSFER(<z0>)        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, amount1, to]
    TOKEN1(<z0>)                // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0, amount1, to, TOKEN1<z0>()]
    ERC20_TRANSFER(<z0>)        // [to, amount1, amount0, blockTimestampLast, reserve1, reserve0]
    _BURN_LAST_UPDATE(<z0>)     // [to, amount1, amount0]
    UNLOCK()                    // [to, amount1, amount0]
    _BURN_FINAL_RETURN(<z0>)    // []
    // returns:                    []
}

#define macro _BURN_AMOUNT() = takes(0) returns(1) {
    // takes:                      []
    address                     // [address()]
    sload                       // [amount]
    // returns:                    [amount]
}

#define macro _BURN_FINAL_RETURN(z0) = takes(3) returns(0) {
    // takes:                      [to, amount1, amount0]
    <z0>                        // [to, amount1, amount0, z0]
    mstore                      // [to, amount1]
    0x20                        // [to, amount1, 0x20]
    mstore                      // [to]
    caller                      // [to, caller()]
    __EVENT_HASH(Burn)     // [to, caller(), _BURN_EVENT_SIGNATURE]
    0x40                        // [to, caller(), _BURN_EVENT_SIGNATURE, 0x40]
    <z0>                        // [to, caller(), _BURN_EVENT_SIGNATURE, 0x40, z0]
    log3                        // []
    0x40                        // [0x40]
    <z0>                        // [0x40, z0]
    return                      // []
    // returns:                    []
}

#define macro _BURN_LAST_UPDATE(z0) = takes(3) returns(0) {
    // takes:                      [blockTimestampLast, reserve1, reserve0]
    swap2                       // [reserve0, reserve1, blockTimestampLast]
    SELF_BALANCE_TOKEN0(<z0>)   // [reserve0, reserve1, blockTimestampLast, balance0]
    swap2                       // [reserve0, balance0, blockTimestampLast, reserve1]
    SELF_BALANCE_TOKEN1(<z0>)   // [reserve0, balance0, blockTimestampLast, reserve1, balance1]
    swap4                       // [balance1, balance0, blockTimestampLast, reserve1, reserve0]
    dup5                        // [balance1, balance0, blockTimestampLast, reserve1, reserve0, balance1]
    dup5                        // [balance1, balance0, blockTimestampLast, reserve1, reserve0, balance1, balance0]
    _UPDATE(<z0>)               // [balance1, balance0]
    mul                         // [kLast]
    [KLAST_SLOT]                // [kLast, KLAST_SLOT]
    sstore                      // []
    // returns:                    []
}

#define macro _TOTAL_SUPPLY() = takes(0) returns(1) {
    // takes:                      []
    [TOTAL_SUPPLY_SLOT]         // [TOTAL_SUPPLY_SLOT]
    sload                       // [totalSupply]
    // returns:                    [totalSupply]
}
// balls-insert-end

// balls-insert-start
#define macro SKIM(z0) = takes(0) returns(0) {
    // takes:                      []
    0x4                         // [0x4]
    calldataload                // [skimmer]
    dup1                        // [skimmer, skimmer]
    LOCK(<z0>)                  // [skimmer, skimmer]
    [PACKED_RESERVE_SLOT]       // [skimmer, skimmer, PACKED_RESERVE_SLOT]
    sload                       // [skimmer, skimmer, packedReserveSlot]
    dup1                        // [skimmer, skimmer, packedReserveSlot, packedReserveSlot]
    _GET_RESERVE0()             // [skimmer, skimmer, packedReserveSlot, reserve0]
    swap1                       // [skimmer, skimmer, reserve0, packedReserveSlot]
    _GET_RESERVE1()             // [skimmer, skimmer, reserve0, reserve1]
    SELF_BALANCE_TOKEN1(<z0>)   // [skimmer, skimmer, reserve0, reserve1, token1Balance]
    swap2                       // [skimmer, skimmer, token1Balance, reserve1, reserve0]
    SELF_BALANCE_TOKEN0(<z0>)   // [skimmer, skimmer, token1Balance, reserve1, reserve0, token0Balance]
    SAFE_SUB(<z0>)              // [skimmer, skimmer, token1Balance, reserve1, skim0]
    swap2                       // [skimmer, skimmer, skim0, reserve1, token1Balance]
    SAFE_SUB(<z0>)              // [skimmer, skimmer, skim0, skim1]
    swap3                       // [skim1, skimmer, skim0, skimmer]
    TOKEN0(<z0>)                // [skim1, skimmer, skim0, skimmer, TOKEN0<z0>()]
    ERC20_TRANSFER(<z0>)        // [skim1, skimmer]
    TOKEN1(<z0>)                // [skim1, skimmer, TOKEN1<z0>()]
    ERC20_TRANSFER(<z0>)        // []
    UNLOCK()                    // []
    stop                        // []
    // returns:                    []
}
// balls-insert-end

// balls-insert-start
#define macro SYNC(z0) = takes(0) returns(0) {
    // takes:                      []
    LOCK(<z0>)                  // []
    [PACKED_RESERVE_SLOT]       // [PACKED_RESERVE_SLOT]
    sload                       // [packedReserveSlot]
    dup1                        // [packedReserveSlot, packedReserveSlot]
    _GET_RESERVE0()             // [packedReserveSlot, reserve0]
    swap1                       // [reserve0, packedReserveSlot]
    dup1                        // [reserve0, packedReserveSlot, packedReserveSlot]
    _GET_RESERVE1()             // [reserve0, packedReserveSlot, reserve1]
    swap1                       // [reserve0, reserve1, packedReserveSlot]
    _GET_BLOCK_TIMESTAMP_LAST()
    //                             [reserve0, reserve1, blockTimestampLast]
    swap2                       // [blockTimestampLast, reserve1, reserve0]
    SELF_BALANCE_TOKEN0(<z0>)   // [blockTimestampLast, reserve1, reserve0, balance0]
    dup1                        // [blockTimestampLast, reserve1, reserve0, balance0, balance0]
    REQUIRE(<z0>, 0xbb55fd27)   // [blockTimestampLast, reserve1, reserve0, balance0]
    SELF_BALANCE_TOKEN1(<z0>)   // [blockTimestampLast, reserve1, reserve0, balance0, balance1]
    swap1                       // [blockTimestampLast, reserve1, reserve0, balance1, balance0]
    dup2                        // [blockTimestampLast, reserve1, reserve0, balance1, balance0, balance1]
    REQUIRE(<z0>, 0xbb55fd27)   // [blockTimestampLast, reserve1, reserve0, balance1, balance0]
    _UPDATE(<z0>)               // []
    UNLOCK()                    // []
    stop                        // []
    // returns:                    []
}
// balls-insert-end

#define macro _TRANSFER_IF_NOT_ZERO(z0) = takes(3) returns(0) {
    // takes:                      [amount, to, TOKEN]
    dup3 iszero skipTransferJump jumpi
    
    dup3                        // [amount, to, TOKEN, amount]
    dup3                        // [amount, to, TOKEN, amount, to]
    dup3                        // [amount, to, TOKEN, amount, to, TOKEN]
    
    ERC20_TRANSFER(<z0>)        // [amount, to, TOKEN]

    skipTransferJump:
    // stack:                      [amount, to, TOKEN]
    pop                         // [amount, to]
    pop                         // [amount]
    pop                         // []
    
    // returns:                    []
}

#define macro _UNISWAP_V2_CALL_IF_DATA(z0) = takes(3) returns(0) {  
  // takes:                      [to, amount0Out, amount1Out]
  0x84 calldataload          // length of data
  iszero                     // data.length == 0
  skipHook jumpi             // if data.length == 0, jump to skipCallJump
  dup3                       // [to, amount0Out, amount1Out, to]
  dup3                       // [to, amount0Out, amount1Out, to, amount0Out]
  dup3                       // [to, amount0Out, amount1Out, to, amount0Out, amount1Out]
  _UNISWAP_V2_CALL(<z0>)       // [to, amount0Out, amount1Out]

  skipHook:
  pop
  pop
  pop
}


// balls-insert-start
#define macro KCHECK(z0) = takes(4) returns(0) {
    // takes:                      [reserve1, reserve0, balance1, balance0]
    0xf4240                     // [reserve1, reserve0, balance1, balance0, 0xf4240]
    dup2                        // [reserve1, reserve0, balance1, balance0, 0xf4240, balance0]
    dup5                        // [reserve1, reserve0, balance1, balance0, 0xf4240, balance0, reserve0]
    _CALC_AMOUNT0in()           // [reserve1, reserve0, balance1, balance0, 0xf4240, amount0In]
    swap4                       // [reserve1, amount0In, balance1, balance0, 0xf4240, reserve0]
    dup4                        // [reserve1, amount0In, balance1, balance0, 0xf4240, reserve0, balance1]
    dup7                        // [reserve1, amount0In, balance1, balance0, 0xf4240, reserve0, balance1, reserve1]
    _CALC_AMOUNT1in()           // [reserve1, amount0In, balance1, balance0, 0xf4240, reserve0, amount1In]
    swap6                       // [amount1In, amount0In, balance1, balance0, 0xf4240, reserve0, reserve1]
    mul                         // [amount1In, amount0In, balance1, balance0, 0xf4240, mul(reserve1, reserve0)]
    mul                         // [amount1In, amount0In, balance1, balance0, k]
    swap2                       // [amount1In, amount0In, k, balance0, balance1]
    [MINIMUM_LIQUIDITY]         // [amount1In, amount0In, k, balance0, balance1, MINIMUM_LIQUIDITY]
    mul                         // [amount1In, amount0In, k, balance0, mul(MINIMUM_LIQUIDITY, balance1)]
    0x3                         // [amount1In, amount0In, k, balance0, mul(MINIMUM_LIQUIDITY, balance1), 0x3]
    dup6                        // [amount1In, amount0In, k, balance0, mul(MINIMUM_LIQUIDITY, balance1), 0x3, amount1In]
    mul                         // [amount1In, amount0In, k, balance0, mul(MINIMUM_LIQUIDITY, balance1), mul(amount1In, 0x3)]
    0x3                         // [amount1In, amount0In, k, balance0, mul(MINIMUM_LIQUIDITY, balance1), mul(amount1In, 0x3), 0x3]
    dup6                        // [amount1In, amount0In, k, balance0, mul(MINIMUM_LIQUIDITY, balance1), mul(amount1In, 0x3), 0x3, amount0In]
    mul                         // [amount1In, amount0In, k, balance0, mul(MINIMUM_LIQUIDITY, balance1), mul(amount1In, 0x3), mul(amount0In, 0x3)]
    swap2                       // [amount1In, amount0In, k, balance0, mul(amount0In, 0x3), mul(amount1In, 0x3), mul(MINIMUM_LIQUIDITY, balance1)]
    sub                         // [amount1In, amount0In, k, balance0, mul(amount0In, 0x3), balance1Adjusted]
    swap2                       // [amount1In, amount0In, k, balance1Adjusted, mul(amount0In, 0x3), balance0]
    [MINIMUM_LIQUIDITY]         // [amount1In, amount0In, k, balance1Adjusted, mul(amount0In, 0x3), balance0, MINIMUM_LIQUIDITY]
    mul                         // [amount1In, amount0In, k, balance1Adjusted, mul(amount0In, 0x3), mul(MINIMUM_LIQUIDITY, balance0)]
    sub                         // [amount1In, amount0In, k, balance1Adjusted, balance0Adjusted]
    mul                         // [amount1In, amount0In, k, newK]
    gt                          // [amount1In, amount0In, gt(newK, k)]
    REQUIRE(<z0>, 0x35b01a0f)   // [amount1In, amount0In]
    _EMIT_SWAP_EVENT(<z0>)      // []
    // returns:                    []
}

#define macro SWAP(z0) = takes(0) returns(0) {
    // takes:                      []
    [PACKED_RESERVE_SLOT]       // [PACKED_RESERVE_SLOT]
    LOCK(<z0>)                  // [PACKED_RESERVE_SLOT]
    sload                       // [packedReserveSlot]
    dup1                        // [packedReserveSlot, packedReserveSlot]
    _GET_RESERVE0()             // [packedReserveSlot, reserve0]
    0x24                        // [packedReserveSlot, reserve0, 0x24]
    calldataload                // [packedReserveSlot, reserve0, amount1Out]
    dup1                        // [packedReserveSlot, reserve0, amount1Out, amount1Out]
    0x4                         // [packedReserveSlot, reserve0, amount1Out, amount1Out, 0x4]
    calldataload                // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out]
    [ADDRESS_MASK]              // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, ADDRESS_MASK]
    0x44                        // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, ADDRESS_MASK, 0x44]
    calldataload                // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, ADDRESS_MASK, calldataload(0x44)]
    and                         // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, to]
    dup5                        // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, to, reserve0]
    dup3                        // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, to, reserve0, amount0Out]
    lt                          // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0)]
    dup7                        // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), packedReserveSlot]
    _GET_RESERVE1()             // [packedReserveSlot, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), reserve1]
    swap7                       // [reserve1, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), packedReserveSlot]
    dup3                        // [reserve1, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), packedReserveSlot, to]
    dup7                        // [reserve1, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), packedReserveSlot, to, amount1Out]
    dup6                        // [reserve1, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), packedReserveSlot, to, amount1Out, amount0Out]
    _SWAP_CHECK_INPUTS(<z0>)    // [reserve1, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), packedReserveSlot]
    _GET_BLOCK_TIMESTAMP_LAST()
    //                             [reserve1, reserve0, amount1Out, amount1Out, amount0Out, to, lt(amount0Out, reserve0), blockTimestampLast]
    swap5                       // [reserve1, reserve0, blockTimestampLast, amount1Out, amount0Out, to, lt(amount0Out, reserve0), amount1Out]
    dup8                        // [reserve1, reserve0, blockTimestampLast, amount1Out, amount0Out, to, lt(amount0Out, reserve0), amount1Out, reserve1]
    gt                          // [reserve1, reserve0, blockTimestampLast, amount1Out, amount0Out, to, lt(amount0Out, reserve0), gt(reserve1, amount1Out)]
    or                          // [reserve1, reserve0, blockTimestampLast, amount1Out, amount0Out, to, or(gt(reserve1, amount1Out), lt(amount0Out, reserve0))]
    REQUIRE(<z0>, 0xbb55fd27)   // [reserve1, reserve0, blockTimestampLast, amount1Out, amount0Out, to]
    _TRANSFER_SWAP_HOOK(<z0>)   // [reserve1, reserve0, blockTimestampLast]
    SELF_BALANCE_TOKEN0(<z0>)   // [reserve1, reserve0, blockTimestampLast, balance0]
    SELF_BALANCE_TOKEN1(<z0>)   // [reserve1, reserve0, blockTimestampLast, balance0, balance1]
    swap2                       // [reserve1, reserve0, balance1, balance0, blockTimestampLast]
    dup5                        // [reserve1, reserve0, balance1, balance0, blockTimestampLast, reserve1]
    dup5                        // [reserve1, reserve0, balance1, balance0, blockTimestampLast, reserve1, reserve0]
    dup5                        // [reserve1, reserve0, balance1, balance0, blockTimestampLast, reserve1, reserve0, balance1]
    dup5                        // [reserve1, reserve0, balance1, balance0, blockTimestampLast, reserve1, reserve0, balance1, balance0]
    _UPDATE(<z0>)               // [reserve1, reserve0, balance1, balance0]
    KCHECK(<z0>)                // []
    UNLOCK()                    // []
    stop                        // []
    // returns:                    []
}

#define macro _CALC_AMOUNT0in() = takes(2) returns(1) {
    // takes:                      [balance0, reserve0]
    sub                         // [amount0In]
    0x0                         // [amount0In, 0x0]
    dup2                        // [amount0In, 0x0, amount0In]
    gt                          // [amount0In, gt(amount0In, 0x0)]
    0x0                         // [amount0In, gt(amount0In, 0x0), 0x0]
    swap2                       // [0x0, gt(amount0In, 0x0), amount0In]
    TERNARY()                   // [amount0In]
    // returns:                    [amount0In]
}

#define macro _CALC_AMOUNT1in() = takes(2) returns(1) {
    // takes:                      [balance1, reserve1]
    sub                         // [amount1In]
    0x0                         // [amount1In, 0x0]
    dup2                        // [amount1In, 0x0, amount1In]
    gt                          // [amount1In, gt(amount1In, 0x0)]
    0x0                         // [amount1In, gt(amount1In, 0x0), 0x0]
    swap2                       // [0x0, gt(amount1In, 0x0), amount1In]
    TERNARY()                   // [amount1In]
    // returns:                    [amount1In]
}

#define macro _EMIT_SWAP_EVENT(z0) = takes(2) returns(0) {
    // takes:                      [amount1In, amount0In]
    <z0>                        // [amount1In, amount0In, z0]
    mstore                      // [amount1In]
    0x20                        // [amount1In, 0x20]
    mstore                      // []
    0x44                        // [0x44]
    0x4                         // [0x44, 0x4]
    calldataload                // [0x44, calldataload(0x4)]
    0x40                        // [0x44, calldataload(0x4), 0x40]
    mstore                      // [0x44]
    calldataload                // [calldataload(0x44)]
    caller                      // [calldataload(0x44), caller()]
    __EVENT_HASH(Swap)     // [calldataload(0x44), caller(), _SWAP_EVENT_SIGNATURE]
    0x80                        // [calldataload(0x44), caller(), _SWAP_EVENT_SIGNATURE, 0x80]
    0x24                        // [calldataload(0x44), caller(), _SWAP_EVENT_SIGNATURE, 0x80, 0x24]
    calldataload                // [calldataload(0x44), caller(), _SWAP_EVENT_SIGNATURE, 0x80, calldataload(0x24)]
    0x60                        // [calldataload(0x44), caller(), _SWAP_EVENT_SIGNATURE, 0x80, calldataload(0x24), 0x60]
    mstore                      // [calldataload(0x44), caller(), _SWAP_EVENT_SIGNATURE, 0x80]
    <z0>                        // [calldataload(0x44), caller(), _SWAP_EVENT_SIGNATURE, 0x80, z0]
    log3                        // []
    // returns:                    []
}

#define macro _STORE_IN_MEMORY_FOR_UNICALL(z0) = takes(2) returns(0) {
    // takes:                      [amount1Out, amount0Out]
    0x24                        // [amount1Out, amount0Out, 0x24]
    caller                      // [amount1Out, amount0Out, 0x24, caller()]
    0x4                         // [amount1Out, amount0Out, 0x24, caller(), 0x4]
    0x84                        // [amount1Out, amount0Out, 0x24, caller(), 0x4, 0x84]
    calldatasize                // [amount1Out, amount0Out, 0x24, caller(), 0x4, 0x84, calldatasize()]
    sub                         // [amount1Out, amount0Out, 0x24, caller(), 0x4, sub(calldatasize(), 0x84)]
    0x84                        // [amount1Out, amount0Out, 0x24, caller(), 0x4, sub(calldatasize(), 0x84), 0x84]
    0x84                        // [amount1Out, amount0Out, 0x24, caller(), 0x4, sub(calldatasize(), 0x84), 0x84, 0x84]
    calldatacopy                // [amount1Out, amount0Out, 0x24, caller(), 0x4]
    __FUNC_SIG("uniswapV2Call(address,uint256,uint256,bytes)")         // [amount1Out, amount0Out, 0x24, caller(), 0x4, SIG_uniswapV2Call]
    0xe0                        // [amount1Out, amount0Out, 0x24, caller(), 0x4, SIG_uniswapV2Call, 0xe0]
    shl                         // [amount1Out, amount0Out, 0x24, caller(), 0x4, shiftedFunctionSig]
    <z0>                        // [amount1Out, amount0Out, 0x24, caller(), 0x4, shiftedFunctionSig, z0]
    mstore                      // [amount1Out, amount0Out, 0x24, caller(), 0x4]
    mstore                      // [amount1Out, amount0Out, 0x24]
    mstore                      // [amount1Out]
    0x44                        // [amount1Out, 0x44]
    mstore                      // []
    0x80                        // [0x80]
    0x64                        // [0x80, 0x64]
    mstore                      // []
    // returns:                    []
}

#define macro _SWAP_CHECK_INPUTS(z0) = takes(3) returns(0) {
    // takes:                      [to, amount1Out, amount0Out]
    or                          // [to, or(amount0Out, amount1Out)]
    REQUIRE(<z0>, 0x42301c23)   // [to]
    dup1                        // [to, to]
    TOKEN0(<z0>)                // [to, to, TOKEN0<z0>()]
    eq                          // [to, eq(TOKEN0<z0>(), to)]
    iszero                      // [to, iszero(eq(TOKEN0<z0>(), to))]
    REQUIRE(<z0>, 0x290fa188)   // [to]
    TOKEN1(<z0>)                // [to, TOKEN1<z0>()]
    eq                          // [eq(TOKEN1<z0>(), to)]
    iszero                      // [iszero(eq(TOKEN1<z0>(), to))]
    REQUIRE(<z0>, 0x290fa188)   // []
    // returns:                    []
}

#define macro _TRANSFER_SWAP_HOOK(z0) = takes(3) returns(0) {
    // takes:                      [amount1Out, amount0Out, to]
    dup3                        // [amount1Out, amount0Out, to, amount1Out]
    dup3                        // [amount1Out, amount0Out, to, amount1Out, amount0Out]
    dup3                        // [amount1Out, amount0Out, to, amount1Out, amount0Out, to]
    TOKEN0(<z0>)                // [amount1Out, amount0Out, to, amount1Out, amount0Out, to, TOKEN0<z0>()]
    _TRANSFER_IF_NOT_ZERO(<z0>)
    //                             [amount1Out, amount0Out, to, amount1Out]
    dup2                        // [amount1Out, amount0Out, to, amount1Out, to]
    TOKEN1(<z0>)                // [amount1Out, amount0Out, to, amount1Out, to, TOKEN1<z0>()]
    _TRANSFER_IF_NOT_ZERO(<z0>)
    //                             [amount1Out, amount0Out, to]
    _UNISWAP_V2_CALL_IF_DATA(<z0>)
    //                             []
    // returns:                    []
}

#define macro _UNISWAP_V2_CALL(z0) = takes(3) returns(0) {
    // takes:                      [amount1Out, amount0Out, to]
    swap2                       // [to, amount0Out, amount1Out]
    <z0>                        // [to, amount0Out, amount1Out, z0]
    swap2                       // [to, z0, amount1Out, amount0Out]
    _STORE_IN_MEMORY_FOR_UNICALL(<z0>)
    //                             [to, z0]
    calldatasize                // [to, z0, calldatasize()]
    <z0>                        // [to, z0, calldatasize(), z0]
    <z0>                        // [to, z0, calldatasize(), z0, z0]
    <z0>                        // [to, z0, calldatasize(), z0, z0, z0]
    swap5                       // [z0, z0, calldatasize(), z0, z0, to]
    gas                         // [z0, z0, calldatasize(), z0, z0, to, gas()]
    call                        // [callOk]
    REQUIRE(<z0>, 0x7fd1918d)   // []
    // returns:                    []
}
// balls-insert-end

// balls-insert-start
#define macro SELF_BALANCE_TOKEN0(z0) = takes(0) returns(1) {
    // takes:                      []
    address                     // [address()]
    TOKEN0(<z0>)                // [address(), TOKEN0<z0>()]
    ERC20_BALANCE_OF(<z0>)      // [amount]
    // returns:                    [amount]
}

#define macro SELF_BALANCE_TOKEN1(z0) = takes(0) returns(1) {
    // takes:                      []
    address                     // [address()]
    TOKEN1(<z0>)                // [address(), TOKEN1<z0>()]
    ERC20_BALANCE_OF(<z0>)      // [amount]
    // returns:                    [amount]
}
// balls-insert-end